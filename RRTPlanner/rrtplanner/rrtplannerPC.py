"""
    The main class RRTPlannerPC.

    This constitutes a demo of a 3D planning of a holonomic robot with point-like obstacles. This code is usable
    when the robot is navigating locally in a point cloud (such as one captured by a LiDAR).
    Both the traversable space and the obstacles are represented by a set of 3D points. These points are assumed
    to be captured by a LiDAR. Each LiDAR point is classified as traversable or non-traversable (obstacle).

    In this case, the slight modifications with respect to the main RRT algorithms (see references below) are:
    - In the random_config phase, a traversable point qrand is ramdomly selected from the traversable pointcloud.
    - Next, a qnew is generated by moving towards qrand from qnear.
    - Next, important, the closest point to qnew in the traversable cloud is selected. This ensures that the path
    and the solution, at least, is placed over a traversable point.

    Please, read:
    - RRT-connect: An efficient approach to single-query path planning. J. J. Kuffner and S. M. LaValle. In Proceedings IEEE International Conference on Robotics and Automation, pages 995-1001, 2000. [pdf].
    - Rapidly-exploring random trees: A new tool for path planning. S. M. LaValle. TR 98-11, Computer Science Dept., Iowa State University, October 1998, [pdf].

    The minor variation with respect to the basic algorithm is that, after max_nodes iterations, the
    algorithm always returns a solution:
        a) If the goal is reached, the path that connects the start and goal is returned.
        b) If the goal is not reached, the node that is found closest to the goal is found.
           Next, the path that connects the start and the closest node is returned.
    This behaviour is not optimal, however, it yields, sometimes, necessary to have always
    a local path to follow in the context of mobile robotics. It yields probable, that, in the next
    observations, a valid path is found that allows the robot to reach the goal.
"""
import numpy as np
import matplotlib.pyplot as plt
from rrtplanner.tree import Tree

# from rrtplanner.rrtplanner import RRTPlanner

REACHED = 0
ADVANCED = 1
TRAPPED = 2
GOAL_REACHED = 3


class RRTPlannerPC():
    """
    A Basic RRT Planner in a 3D  point cloud for holonomic robots.
    """

    def __init__ (self, start, goal, pc_traversable, pc_obstacles, epsilon, max_nodes, robot_radius=0.7):

        # RRTPlanner.__init__(self, start=start, goal=goal, dimensions=None,
        #                     obstacles=None, epsilon=epsilon, max_nodes=max_nodes)
        self.goal = np.array(goal)
        self.start = np.array(start)
        self.max_nodes = max_nodes
        self.epsilon = epsilon
        # traversable space and obstacles, +- dimensions in XY
        # a set of 3D traversable points
        self.pc_traversable = np.array(pc_traversable)
        # a set of 3D points considered non-traversable (obstacles)
        self.pc_obstacles = np.array(pc_obstacles)
        # stores info on the result of the algorithm
        self.goal_reached = False
        self.iterations_performed = 0
        # robot dimensions
        self.robot_radius = robot_radius

        # add inner circles to ensure traversability in the nearings of the robot
        points = self.build_inner_circles_localCoords()
        # points=self.build_robot_box()
        self.pc_traversable = np.vstack((self.pc_traversable, points))
        if self.collision(self.start) or self.goal_collision(self.goal):
            raise Exception('Start or goal are inside the obstacle space')

    def build_rrt_basic (self, try_obvious=True):
        """
        Programmed using the same names as in:
        RRT-connect: An efficient approach to single-query path planning.
        J. J. Kuffner and S. M. LaValle.
        In Proceedings IEEE International Conference on Robotics and Automation,
        pages 995-1001, 2000.
        """
        tree = Tree(self.start)
        for k in range(self.max_nodes):
            print('Iteration: ', k)
            if (k == 0) and try_obvious:
                qrand = self.goal
            else:
                qrand = self.random_config()
            result, qnew = self.extend(tree, qrand)
            if self.reached_goal(qnew):
                self.goal_reached = True
                self.iterations_performed = k
                break
        self.iterations_performed = k
        return tree

    def build_rrt_connect (self, try_obvious=True):
        """
        Basic RRT-connect algorithm. Two trees are used.
        The try_obvious option generates, as a first qrand sample, the qgoal.
        This directs the search towards the goal. In the case in which the search space that connects
        start and goal is free, this may produce a straigth line. This is a nice modification that simplifies
        path planning and tries to find the simplest solution first.

        RRT-connect: An efficient approach to single-query path planning.
        J. J. Kuffner and S. M. LaValle.
        In Proceedings IEEE International Conference on Robotics and Automation,
        pages 995-1001, 2000.
        """
        # use two trees in this case
        t1 = Tree(self.start)
        t2 = Tree(self.goal)
        tA = t1
        tB = t2
        for k in range(self.max_nodes):
            print('Iteration: ', k)
            if (k == 0) and try_obvious:
                qrand = self.goal
            else:
                qrand = self.random_config()
            result, qnew = self.extend(tA, qrand)
            if not (result == TRAPPED):
                result, qfinal = self.connect(tB, qnew)
                # in RRT connect, a REACHED, means that both trees could be connected.
                if (result == REACHED) or (result == GOAL_REACHED):
                    # In this case, we mark the two nodes as reached (in both trees)
                    nodeneartA = tA.nearest_neighbour(qfinal)
                    tA.mark_node_as_reached(nodeneartA.id)
                    nodeneartB = tB.nearest_neighbour(qfinal)
                    tB.mark_node_as_reached(nodeneartB.id)
                    self.goal_reached = True
                    self.iterations_performed = k
                    return t1, t2
            # swap trees
            tA, tB = self.swap(tA, tB)
        return t1, t2

    def build_rrt_connect_to_goal (self, try_obvious=True):
        """
        Programmed using the same names as in:
        This is a simplified version of the RRT-connect algorithm using a single
        tree. The connect operation always tries to connect the tree to the goal.
        RRT-connect: An efficient approach to single-query path planning.
        J. J. Kuffner and S. M. LaValle.
        In Proceedings IEEE International Conference on Robotics and Automation,
        pages 995-1001, 2000.
        """
        # use a single tree in this case
        # no swap operation needed
        tree = Tree(self.start)
        for k in range(self.max_nodes):
            print('Iteration: ', k)
            if k == 0 and try_obvious:
                qrand = self.goal
            else:
                qrand = self.random_config()
            result, qnew = self.extend(tree, qrand)
            if not (result == TRAPPED):
                result, qfinal = self.connect(tree, self.goal)
                # in RRT connect, a REACHED, means that both trees could be connected.
                if (result == REACHED) or (result == GOAL_REACHED):
                    # In this case, we mark the two nodes as reached (in both trees)
                    self.goal_reached = True
                    self.iterations_performed = k
                    return tree
        return tree

    def random_config (self):
        """
        This generates a new random configuration.
        In this particular problem, a random sample is selected from the list of traversable points.
        :return:
        """
        N = self.pc_traversable.shape[0]
        i = np.random.choice(N, 1)[0]
        return self.pc_traversable[i, :]

    def extend (self, tree, qrand):
        """
        The extend operation of the tree.
        A result is added to this operation to indicate that qnew reached the goal
        The REACHED result is not considered in this case
        :param qrand:
        :return:
        """
        # nearest neighbour in tree
        node_near = self.nearest_neighbour(tree, qrand)
        # self.plot_point(q)
        # a new configuration between qrand and qnear
        qnew = self.new_config(node_near.coordinates, qrand)
        # self.plot_point(qnew)
        # self.plot_point3d(qnew)
        # now, important, select the closest real point in the traversable space within
        # a distance of epsilon

        # we are now checking whether there are traversable points within an epsilon distance of the new qnew
        d, _ = self.nearest_distance_to_points(self.pc_traversable, qnew)
        # caution: this case is not trapped by obstacles, however, no traversable points
        # are found next to qnew. It is, somewhat, a similar case, since, if no known traversable points
        # are in the area, the algorithm decides not to traverse over empty space
        if d > self.epsilon:
            return TRAPPED, qnew

        if not self.collision(qnew):
            goal_reached = self.reached_goal(qnew)
            reached_new_config = self.distance(qnew, qrand) < self.epsilon
            # if goal_reached:
            #     tree.add_vertex(parent_id=node_near.id, coordinates=qnew, goal_reached=True)
            #     return GOAL_REACHED, qnew
            if reached_new_config:
                tree.add_vertex(parent_id=node_near.id, coordinates=qnew, goal_reached=goal_reached)
                return REACHED, qnew
            else:
                tree.add_vertex(parent_id=node_near.id, coordinates=qnew, goal_reached=goal_reached)
                return ADVANCED, qnew
        return TRAPPED, qnew

    def connect (self, tree, q):
        while True:
            result, qfinal = self.extend(tree, q)
            if not (result == ADVANCED):
                break
        return result, qfinal

    def new_config (self, qnear, qrand):
        """
        Computes a new configuration between qnear and qrand that is placed at an epsilon distance from qnear
        :param qnear: a node in the tree
        :param qrand: a random configuration
        :return:
        """
        ds = qrand - qnear
        n = np.linalg.norm(ds)
        if n > 0:
            du = ds / n
            qnew = qnear + self.epsilon * du

            return qnew
        return qnear

    # def collision(self, q):
    #     """
    #     Returns True if q is in the obstacle space (it is colliding), false elsewise
    #     :param q:
    #     :return:
    #     """
    #     for i in range(len(self.obstacles)):
    #         obstacle = self.obstacles[i]
    #         d = np.linalg.norm(q-obstacle[0:2])
    #         if d < obstacle[2]:
    #             return True
    #     return False

    def collision (self, q):
        """
        **
        Returns True if q is in the obstacle space, false elsewise.
                Here, checking whether there are points in pc_obstacle within a radius R of the robot
        :param q:
        :return:
        """
        d, _ = self.nearest_distance_to_points(self.pc_obstacles, q)
        if d < self.robot_radius:
            return True
        return False

    def goal_collision (self, q):
        """
        **
        Returns True if q is in the obstacle space, false elsewise.
                Here, checking whether there are points in pc_obstacle within a radius R of the robot
        :param q:
        :return:
        """
        d, _ = self.nearest_distance_to_points(self.pc_obstacles, q)
        if d < self.robot_radius + 0.0:
            return True
        return False

    def nearest_neighbour (self, tree, qrand):
        """
        Returns the index in the tree that is nearest to qrand
        :param qrand:
        :return:
        """
        node = tree.nearest_neighbour(qrand)
        return node

    # def nearest_neighbour_point(self, points, q):
    #     """
    #     Returns the index in the tree that is nearest to qrand
    #     :param qrand:
    #     :return:
    #     """
    #     dists = np.linalg.norm(points - q, axis=1)
    #     d = np.min(dists)
    #     return d

    def nearest_distance_to_points (self, points, q):
        """
        Returns the index in the tree that is nearest to qrand
        :param qrand:
        :return:
        """
        dists = np.linalg.norm(points - q, axis=1)
        idx = np.argmin(dists)
        d = dists[idx]
        return d, points[idx, :]

    def reached_goal (self, q):
        d = self.distance(q, self.goal)
        if d < self.epsilon:
            return True
        return False

    def distance (self, qa, qb):
        d = np.linalg.norm(qa - qb)
        return d

    def get_solution_path (self, tree):
        """
        This method:
        a) looks for the node/nodes that are marked as "reached the goal"
        b) for each node marked as reached, backtraces the path until the root is found.
        c) The path is returned.
        If no node is found as goal_reached, then the closest node to the goal is found and treated as the solution node
        :return:
        """
        solution_node = tree.find_node_reached()
        # if no solution is found, then find the nearest neighbour in the tree to the goal
        if solution_node is None:
            solution_node = self.nearest_neighbour(tree, self.goal)
            solution_path = tree.back_trace_path_from_node(solution_node)
        else:
            # standard solution
            solution_path = tree.back_trace_path_from_node(solution_node)
            # in this case (reached goal), the goal coordinates are inserted at the beginning
            solution_path.insert(0, np.array(self.goal))
        # change order of the path!!
        solution_path.reverse()
        solution_path = np.array(solution_path)
        return solution_path

    def swap (self, tA, tB):
        # swap trees
        temp = tA
        tA = tB
        tB = temp
        return tA, tB

    def build_inner_circles_globalCoords (self, inner_radius=0.3, outer_radius=1.0, z=0.0):
        theta = np.linspace(0, 2 * np.pi, 50)
        R = np.linspace(inner_radius, outer_radius, 2)
        points = []
        print(self.start[0])
        for r in R:
            for th in theta:
                x = r * np.cos(th) + self.start[0]
                y = r * np.sin(th) + self.start[1]
                points.append(np.array([x, y, self.start[2]]))
        points = np.array(points)
        return points

    def build_inner_circles_localCoords (self, inner_radius=0.3, outer_radius=1.0, z=0.0):
        theta = np.linspace(0, 2 * np.pi, 50)
        R = np.linspace(inner_radius, outer_radius, 2)
        points = []
        print(self.start[0])
        for r in R:
            for th in theta:
                x = r * np.cos(th)
                y = r * np.sin(th)
                points.append(np.array([x, y, z]))
        points = np.array(points)
        return points
    def build_robot_box (self, width=60, length=100, z=0.243):

        width = int(width / 2)
        length = int(length / 2)
        x1 = -width
        x2 = width
        y1 = length
        y2 = -length
        points = []
        for x in range(x1, x2 + 1, 4):
            plt.scatter(x, y1)
            points.append((x/100 + self.start[0], y1/100 + self.start[1], z))
            # Right edge (excluding top-right corner)
        for y in range(y1, y2, -4):
            plt.scatter(x2, y)
            points.append((x2/100 + self.start[0], y/100 + self.start[1], z))
            # Bottom edge (excluding bottom-right corner)
        for x in range(x2 - 1, x1 - 1, -4):
            plt.scatter(x, y2)
            points.append((x/100 + self.start[0], y2/100 + self.start[1], z))
            # Left edge (excluding bottom-left corner)
        for y in range(y2, y1, 4):
            plt.scatter(x1, y)
            points.append((x1/100 + self.start[0], y/100 + self.start[1], z))

        # plt.show()
        return points

    def get_solution_path_from_two_trees (self, treeA, treeB):
        """
        This method looks for the global path that connects the two trees.
        Several cases appear, in the most common, both trees have one of the
        nodes marked as reached. This means that they reached the other tree.

        treeA is assumed to be rooted by the start position.
        treeB is assumed to be rooted by the goal position position.

        :return:
        """
        solution_nodeA = treeA.find_node_reached()
        solution_nodeB = treeB.find_node_reached()
        # standard case
        if (solution_nodeA is not None) and (solution_nodeB is not None):
            # standard solution
            solution_pathA = treeA.back_trace_path_from_node(solution_nodeA)
            solution_pathA.reverse()
            solution_pathB = treeB.back_trace_path_from_node(solution_nodeB)
            solution_pathA = np.array(solution_pathA)
            solution_pathB = np.array(solution_pathB)
            solution_path = np.vstack((solution_pathA, solution_pathB))
        # no solution was found
        if (solution_nodeA is None) or (solution_nodeB is None):
            print('NO SOLUTION COULD BE FOUND')
            solution_path = []
            solution_path = np.array(solution_path)
        return solution_path

    def print_info (self):
        print(30 * '*')
        print('PERFORMED ITERATIONS: ', self.iterations_performed)
        print('GOAL REACHED: ', self.goal_reached)
        print(30 * '*')

    def plot (self):
        # plot obstacles
        plt.scatter(self.pc_obstacles[:, 0], self.pc_obstacles[:, 1], color='black')
        plt.scatter(self.pc_traversable[:, 0], self.pc_traversable[:, 1], color='blue')
        plt.scatter(self.start[0], self.start[1], color='green')
        plt.scatter(self.goal[0], self.goal[1], color='red')
        # if show:
        #     plt.show()

    def plot_point (self, point):
        # plot obstacles
        plt.scatter(self.pc_obstacles[:, 0], self.pc_obstacles[:, 1], color='black')
        plt.scatter(self.pc_traversable[:, 0], self.pc_traversable[:, 1], color='blue')
        plt.scatter(point[0], point[1], color='red')
        plt.show()

    def plot_point3d (self, point):
        fig = plt.figure()
        ax = fig.add_subplot(projection='3d')
        # plot traversable points
        ax.scatter(self.pc_traversable[:, 0], self.pc_traversable[:, 1], self.pc_traversable[:, 2],
                   marker='.', color='blue')
        ax.scatter(self.pc_obstacles[:, 0], self.pc_obstacles[:, 1], self.pc_obstacles[:, 2],
                   marker='.', color='black')
        ax.scatter(point[0], point[1], point[2], color='red')
        plt.show()
